---
import '../styles/global.css'
import { getLangFromUrl } from '../i18n/utils/config'

const lang = getLangFromUrl(Astro.url)
---

<!doctype html>
<html lang={lang} data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>EKOU SOLUTIONS</title>
  </head>
  <body>
    <slot />
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>

<script is:inline>
  ;(() => {
    if (typeof window === 'undefined') return
    const SCROLL_DURATION = 200
    const EXTRA_OFFSET = 12

    const easeLinear = (t) => t

    const getHeaderOffset = () => {
      const header = document.querySelector('[data-site-header]')
      const height = header ? header.getBoundingClientRect().height : 0
      return height + EXTRA_OFFSET
    }

    const smoothScrollTo = (targetY, duration = SCROLL_DURATION) => {
      const startY = window.scrollY || window.pageYOffset
      const diff = targetY - startY
      if (Math.abs(diff) < 1) return

      let startTime
      const step = (timestamp) => {
        if (startTime === undefined) startTime = timestamp
        const elapsed = timestamp - startTime
        const progress = Math.min(elapsed / duration, 1)
        const eased = easeLinear(progress)
        window.scrollTo(0, startY + diff * eased)
        if (elapsed < duration) requestAnimationFrame(step)
      }

      requestAnimationFrame(step)
    }

    const focusSection = (section) => {
      if (!section) return
      const isFocusable = section.matches('a, button, input, textarea, select, details, [tabindex]')
      if (!isFocusable) {
        section.setAttribute('tabindex', '-1')
      }
      section.focus({ preventScroll: true })
    }

    const scrollToHash = (hash) => {
      if (!hash || hash === '#') return false
      const id = decodeURIComponent(hash.slice(1))
      const section = document.getElementById(id)
      if (!section) return false

      const targetTop = section.getBoundingClientRect().top + window.scrollY
      const offsetTop = Math.max(0, targetTop - getHeaderOffset())
      smoothScrollTo(offsetTop)
      focusSection(section)
      return true
    }

    document.addEventListener('click', (event) => {
      if (event.defaultPrevented) return
      if (event.button !== 0) return
      if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return

      const target = event.target
      const element = target instanceof Element ? target : target?.parentElement
      if (!element) return

      const anchor = element.closest('a[href^="#"]')
      if (!anchor) return
      if (anchor.target && anchor.target !== '_self') return

      const href = anchor.getAttribute('href')
      if (!href || !href.startsWith('#')) return

      event.preventDefault()
      if (!scrollToHash(href)) return
      history.pushState(null, '', href)
    })

    window.addEventListener('hashchange', () => {
      scrollToHash(window.location.hash)
    })

    if (window.location.hash) {
      setTimeout(() => scrollToHash(window.location.hash), 80)
    }
  })()
</script>

<script is:inline>
  ;(() => {
    if (typeof window === 'undefined') return
    const links = Array.from(document.querySelectorAll('[data-section-link]'))
    const sections = Array.from(document.querySelectorAll('section[id]'))
    if (!links.length || !sections.length) return

    const setActive = (id) => {
      const hash = `#${id}`
      links.forEach((link) => {
        link.classList.toggle('is-active', link.getAttribute('data-section-link') === hash)
      })
    }

    const observer = new IntersectionObserver(
      (entries) => {
        const visible = entries
          .filter((entry) => entry.isIntersecting)
          .sort((a, b) => b.intersectionRatio - a.intersectionRatio)
        if (!visible.length) return
        setActive(visible[0].target.id)
      },
      {
        rootMargin: '-40% 0px -50% 0px',
        threshold: [0, 0.25, 0.6],
      }
    )

    sections.forEach((section) => observer.observe(section))

    const initial = window.location.hash?.slice(1)
    if (initial) {
      setActive(initial)
    }
  })()
</script>
