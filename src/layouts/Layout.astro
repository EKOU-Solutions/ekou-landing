---
import '../styles/global.css'
import { getLangFromUrl, useTranslations } from '../i18n/utils/config'

const normalizePathname = (pathname) => {
  if (pathname.endsWith('/index.html')) {
    return pathname.replace(/\/index\.html$/, '/')
  }
  return pathname
}

const lang = getLangFromUrl(Astro.url)
const t = useTranslations(lang)
const welcome = t('welcome')
const siteTitle = 'EKOU Solutions'
const description = welcome.description
const canonicalBase = Astro.site ?? Astro.url
const currentPath = normalizePathname(Astro.url.pathname)
const canonicalUrl = new URL(currentPath, canonicalBase).href
const esPath = currentPath.replace(/^\/en(?=\/|$)/, '') || '/'
const enPath = currentPath.startsWith('/en')
  ? currentPath
  : `/en${currentPath === '/' ? '' : currentPath}`
const esUrl = new URL(esPath, canonicalBase).href
const enUrl = new URL(enPath, canonicalBase).href
const ogImage = new URL('/og-image.svg', canonicalBase).href
const ogLocale = lang === 'es' ? 'es_ES' : 'en_US'
const ogLocaleAlt = lang === 'es' ? 'en_US' : 'es_ES'
---

<!doctype html>
<html lang={lang} data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" href="/favicon.ico?v=2" />
    <meta name="generator" content={Astro.generator} />
    <title>{siteTitle}</title>
    <meta name="description" content={description} />
    <link rel="canonical" href={canonicalUrl} />
    <link rel="alternate" hreflang="es" href={esUrl} />
    <link rel="alternate" hreflang="en" href={enUrl} />
    <link rel="alternate" hreflang="x-default" href={esUrl} />
    <meta property="og:title" content={siteTitle} />
    <meta property="og:description" content={description} />
    <meta property="og:type" content="website" />
    <meta property="og:url" content={canonicalUrl} />
    <meta property="og:image" content={ogImage} />
    <meta property="og:locale" content={ogLocale} />
    <meta property="og:locale:alternate" content={ogLocaleAlt} />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={siteTitle} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={ogImage} />
  </head>
  <body>
    <slot />
  </body>
</html>

<script is:inline>
  ;(() => {
    if (typeof window === 'undefined') return
    const SCROLL_DURATION = 200
    const EXTRA_OFFSET = 12

    const easeLinear = (t) => t

    const getHeaderOffset = () => {
      const header = document.querySelector('[data-site-header]')
      const height = header ? header.getBoundingClientRect().height : 0
      return height + EXTRA_OFFSET
    }

    const smoothScrollTo = (targetY, duration = SCROLL_DURATION) => {
      const startY = window.scrollY || window.pageYOffset
      const diff = targetY - startY
      if (Math.abs(diff) < 1) return

      let startTime
      const step = (timestamp) => {
        if (startTime === undefined) startTime = timestamp
        const elapsed = timestamp - startTime
        const progress = Math.min(elapsed / duration, 1)
        const eased = easeLinear(progress)
        window.scrollTo(0, startY + diff * eased)
        if (elapsed < duration) requestAnimationFrame(step)
      }

      requestAnimationFrame(step)
    }

    const focusSection = (section) => {
      if (!section) return
      const isFocusable = section.matches('a, button, input, textarea, select, details, [tabindex]')
      if (!isFocusable) {
        section.setAttribute('tabindex', '-1')
      }
      section.focus({ preventScroll: true })
    }

    const scrollToHash = (hash) => {
      if (!hash || hash === '#') return false
      const id = decodeURIComponent(hash.slice(1))
      const section = document.getElementById(id)
      if (!section) return false

      const targetTop = section.getBoundingClientRect().top + window.scrollY
      const offsetTop = Math.max(0, targetTop - getHeaderOffset())
      smoothScrollTo(offsetTop)
      focusSection(section)
      return true
    }

    document.addEventListener('click', (event) => {
      if (event.defaultPrevented) return
      if (event.button !== 0) return
      if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return

      const target = event.target
      const element = target instanceof Element ? target : target?.parentElement
      if (!element) return

      const anchor = element.closest('a[href^="#"]')
      if (!anchor) return
      if (anchor.target && anchor.target !== '_self') return

      const href = anchor.getAttribute('href')
      if (!href || !href.startsWith('#')) return

      event.preventDefault()
      if (!scrollToHash(href)) return
      history.pushState(null, '', href)
    })

    window.addEventListener('hashchange', () => {
      scrollToHash(window.location.hash)
    })

    if (window.location.hash) {
      setTimeout(() => scrollToHash(window.location.hash), 80)
    }
  })()
</script>

<script is:inline>
  ;(() => {
    if (typeof window === 'undefined') return
    const links = Array.from(document.querySelectorAll('[data-section-link]'))
    const sections = Array.from(document.querySelectorAll('section[id]'))
    if (!links.length || !sections.length) return

    const setActive = (id) => {
      const hash = `#${id}`
      links.forEach((link) => {
        link.classList.toggle('is-active', link.getAttribute('data-section-link') === hash)
      })
    }

    const observer = new IntersectionObserver(
      (entries) => {
        const visible = entries
          .filter((entry) => entry.isIntersecting)
          .sort((a, b) => b.intersectionRatio - a.intersectionRatio)
        if (!visible.length) return
        setActive(visible[0].target.id)
      },
      {
        rootMargin: '-40% 0px -50% 0px',
        threshold: [0, 0.25, 0.6],
      }
    )

    sections.forEach((section) => observer.observe(section))

    const initial = window.location.hash?.slice(1)
    if (initial) {
      setActive(initial)
    }
  })()
</script>
